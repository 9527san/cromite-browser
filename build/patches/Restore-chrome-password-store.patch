From: uazo <uazo@users.noreply.github.com>
Date: Wed, 30 Sep 2020 07:40:01 +0000
Subject: Restore chrome password store

License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
---
 chrome/android/java/AndroidManifest.xml       |   5 +-
 ...e_password_preferences_action_bar_menu.xml |  30 +
 .../settings/PasswordSettings.java            | 754 ++++++++++++++++++
 .../chrome/browser/settings/MainSettings.java |  20 +-
 .../autofill/AutofillClientProviderUtils.java |   1 +
 .../settings/PasswordManagerHandler.java      |  83 ++
 .../settings/PasswordUiView.java              | 215 +++++
 .../settings/PasswordsPreference.java         |   1 +
 .../login_db_deprecation_runner_factory.cc    |   2 +-
 .../android/password_manager_android_util.cc  |   1 +
 .../android/password_ui_view_android.cc       | 379 +++++++++
 .../android/password_ui_view_android.h        | 178 +++++
 .../strings/android_chrome_strings.grd        |   2 +-
 .../autofill/core/common/autofill_features.cc |   1 +
 .../core/browser/buildflags.gni               |   2 +-
 .../password_manager_features_util.cc         |   1 +
 components/sync/service/sync_prefs.cc         |   2 +-
 .../Restore-chrome-password-store.inc         |   5 +
 18 files changed, 1665 insertions(+), 17 deletions(-)
 create mode 100644 chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml
 create mode 100644 chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java
 create mode 100644 chrome/browser/password_manager/android/password_ui_view_android.cc
 create mode 100644 chrome/browser/password_manager/android/password_ui_view_android.h
 create mode 100644 cromite_flags/components/password_manager/core/browser/features/password_features_cc/Restore-chrome-password-store.inc

diff --git a/chrome/android/java/AndroidManifest.xml b/chrome/android/java/AndroidManifest.xml
--- a/chrome/android/java/AndroidManifest.xml
+++ b/chrome/android/java/AndroidManifest.xml
@@ -457,10 +457,9 @@ by a child template that "extends" this file.
             </intent-filter>
         </activity>
 
-        <activity android:name="org.chromium.chrome.browser.AutofillOptionsLauncher"
+        <activity android:name="org.chromium.chrome.browser.AutofillOptionsLauncher" android:exported="false"
             android:theme="@style/Theme.BrowserUI.NoDisplay"
-            android:excludeFromRecents="true"
-            android:exported="true">
+            android:excludeFromRecents="true">
             <intent-filter>
                 <action android:name="android.intent.action.APPLICATION_PREFERENCES" />
                 <category android:name="android.intent.category.DEFAULT" />
diff --git a/chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml b/chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml
new file mode 100644
--- /dev/null
+++ b/chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2017 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto" >
+
+    <item
+        android:id="@+id/menu_id_search"
+        android:icon="@drawable/ic_search"
+        android:title="@string/search"
+        app:showAsAction="always"
+        app:actionViewClass="androidx.appcompat.widget.SearchView" />
+
+    <item
+        android:id="@id/menu_id_targeted_help"
+        android:icon="@drawable/ic_help_and_feedback"
+        android:title="@string/menu_help"
+        android:visibility="gone"
+        app:showAsAction="ifRoom"/>
+
+    <item
+        android:id="@+id/export_passwords"
+        android:title="@string/password_settings_export_action_title"
+        android:contentDescription="@string/password_settings_export_action_description"
+        app:showAsAction="never"/>
+</menu>
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
new file mode 100644
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
@@ -0,0 +1,754 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.chromium.chrome.browser.password_manager.PasswordMetricsUtil.PASSWORD_SETTINGS_EXPORT_METRICS_ID;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.text.SpannableString;
+import android.text.style.ForegroundColorSpan;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.StringRes;
+import androidx.appcompat.widget.Toolbar;
+import androidx.fragment.app.FragmentManager;
+import androidx.preference.Preference;
+import androidx.preference.PreferenceCategory;
+import androidx.preference.PreferenceGroup;
+
+import org.chromium.base.BuildInfo;
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.R;
+import org.chromium.chrome.browser.access_loss.PasswordAccessLossWarningType;
+import org.chromium.chrome.browser.password_check.PasswordCheck;
+import org.chromium.chrome.browser.password_check.PasswordCheckFactory;
+import org.chromium.chrome.browser.password_manager.ManagePasswordsReferrer;
+import org.chromium.chrome.browser.password_manager.PasswordCheckReferrer;
+import org.chromium.chrome.browser.password_manager.PasswordManagerHelper;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.settings.ChromeBaseSettingsFragment;
+import org.chromium.chrome.browser.settings.ChromeManagedPreferenceDelegate;
+import org.chromium.chrome.browser.sync.SyncServiceFactory;
+import org.chromium.chrome.browser.sync.settings.SyncSettingsUtils;
+import org.chromium.components.browser_ui.settings.ChromeBasePreference;
+import org.chromium.components.browser_ui.settings.ChromeSwitchPreference;
+import org.chromium.components.browser_ui.settings.SearchUtils;
+import org.chromium.components.browser_ui.settings.TextMessagePreference;
+import org.chromium.components.browser_ui.styles.SemanticColorUtils;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.signin.base.CoreAccountInfo;
+import org.chromium.components.sync.PassphraseType;
+import org.chromium.components.sync.SyncService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.ui.text.SpanApplier;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Locale;
+
+/**
+ * The "Passwords" screen in Settings, which allows the user to enable or disable password saving,
+ * to view saved passwords (just the username and URL), and to delete saved passwords.
+ *
+ * <p>TODO: crbug.com/372657804 - Make sure that the PasswordSettings is not created in UPM M4.1
+ */
+public class PasswordSettings extends ChromeBaseSettingsFragment
+        implements PasswordListObserver,
+                Preference.OnPreferenceClickListener,
+                SyncService.SyncStateChangedListener {
+    @IntDef({
+        TrustedVaultBannerState.NOT_SHOWN,
+        TrustedVaultBannerState.OFFER_OPT_IN,
+        TrustedVaultBannerState.OPTED_IN
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    private @interface TrustedVaultBannerState {
+        int NOT_SHOWN = 0;
+        int OFFER_OPT_IN = 1;
+        int OPTED_IN = 2;
+    }
+
+    // Keys for name/password dictionaries.
+    public static final String PASSWORD_LIST_URL = "url";
+    public static final String PASSWORD_LIST_NAME = "name";
+    public static final String PASSWORD_LIST_PASSWORD = "password";
+
+    // Used to pass the password id into a new activity.
+    public static final String PASSWORD_LIST_ID = "id";
+
+    // The key for saving |mSearchQuery| to instance bundle.
+    private static final String SAVED_STATE_SEARCH_QUERY = "saved-state-search-query";
+
+    public static final String PREF_SAVE_PASSWORDS_SWITCH = "save_passwords_switch";
+    public static final String PREF_AUTOSIGNIN_SWITCH = "autosignin_switch";
+    public static final String PREF_CHECK_PASSWORDS = "check_passwords";
+    public static final String PREF_TRUSTED_VAULT_BANNER = "trusted_vault_banner";
+    public static final String PREF_KEY_MANAGE_ACCOUNT_LINK = "manage_account_link";
+
+    private static final String PREF_KEY_CATEGORY_SAVED_PASSWORDS = "saved_passwords";
+    private static final String PREF_KEY_CATEGORY_EXCEPTIONS = "exceptions";
+    private static final String PREF_KEY_SAVED_PASSWORDS_NO_TEXT = "saved_passwords_no_text";
+
+    private static final int ORDER_SWITCH = 0;
+    private static final int ORDER_AUTO_SIGNIN_CHECKBOX = 1;
+    private static final int ORDER_CHECK_PASSWORDS = 2;
+    private static final int ORDER_TRUSTED_VAULT_BANNER = 3;
+    private static final int ORDER_MANAGE_ACCOUNT_LINK = 4;
+    private static final int ORDER_SAVED_PASSWORDS = 6;
+    private static final int ORDER_EXCEPTIONS = 7;
+    private static final int ORDER_SAVED_PASSWORDS_NO_TEXT = 8;
+
+    // This request code is not actually consumed today in onActivityResult() but is defined here to
+    // avoid bugs in the future if the request code is reused.
+    private static final int REQUEST_CODE_TRUSTED_VAULT_OPT_IN = 1;
+
+    // Unique request code for the password exporting activity.
+    private static final int PASSWORD_EXPORT_INTENT_REQUEST_CODE = 3485764;
+
+    private boolean mNoPasswords;
+    private boolean mNoPasswordExceptions;
+    private @TrustedVaultBannerState int mTrustedVaultBannerState =
+            TrustedVaultBannerState.NOT_SHOWN;
+
+    private MenuItem mHelpItem;
+    private MenuItem mSearchItem;
+
+    private String mSearchQuery;
+    private Preference mLinkPref;
+    private Menu mMenu;
+
+    private @ManagePasswordsReferrer int mManagePasswordsReferrer;
+    private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
+
+    /** For controlling the UX flow of exporting passwords. */
+    private final ExportFlow mExportFlow = new ExportFlow(PasswordAccessLossWarningType.NONE);
+
+    public ExportFlow getExportFlowForTesting() {
+        return mExportFlow;
+    }
+
+    @Override
+    public void onCreatePreferences(@Nullable Bundle savedInstanceState, @Nullable String rootKey) {
+        mExportFlow.onCreate(
+                savedInstanceState,
+                new ExportFlow.Delegate() {
+                    @Override
+                    public Activity getActivity() {
+                        return PasswordSettings.this.getActivity();
+                    }
+
+                    @Override
+                    public FragmentManager getFragmentManager() {
+                        return PasswordSettings.this.getFragmentManager();
+                    }
+
+                    @Override
+                    public int getViewId() {
+                        return getView().getId();
+                    }
+
+                    @Override
+                    public void runCreateFileOnDiskIntent(Intent intent) {
+                        startActivityForResult(intent, PASSWORD_EXPORT_INTENT_REQUEST_CODE);
+                    }
+
+                    @Override
+                    public Profile getProfile() {
+                        return PasswordSettings.this.getProfile();
+                    }
+                },
+                PASSWORD_SETTINGS_EXPORT_METRICS_ID);
+        mPageTitle.set(getString(R.string.password_manager_settings_title));
+        setPreferenceScreen(getPreferenceManager().createPreferenceScreen(getStyledContext()));
+        PasswordManagerHandlerProvider.getForProfile(getProfile()).addObserver(this);
+
+        if (SyncServiceFactory.getForProfile(getProfile()) != null) {
+            SyncServiceFactory.getForProfile(getProfile()).addSyncStateChangedListener(this);
+        }
+
+        setHasOptionsMenu(true); // Password Export might be optional but Search is always present.
+
+        mManagePasswordsReferrer = getReferrerFromInstanceStateOrLaunchBundle(savedInstanceState);
+
+        if (savedInstanceState == null) return;
+
+        if (savedInstanceState.containsKey(SAVED_STATE_SEARCH_QUERY)) {
+            mSearchQuery = savedInstanceState.getString(SAVED_STATE_SEARCH_QUERY);
+        }
+    }
+
+    @Override
+    public ObservableSupplier<String> getPageTitle() {
+        return mPageTitle;
+    }
+
+    private @ManagePasswordsReferrer int getReferrerFromInstanceStateOrLaunchBundle(
+            Bundle savedInstanceState) {
+        if (savedInstanceState != null
+                && savedInstanceState.containsKey(
+                        PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER)) {
+            return savedInstanceState.getInt(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER);
+        }
+        Bundle extras = getArguments();
+        assert extras.containsKey(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER)
+                : "PasswordSettings must be launched with a manage-passwords-referrer fragment"
+                        + "argument, but none was provided.";
+        return extras.getInt(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER);
+    }
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        computeTrustedVaultBannerState();
+    }
+
+    @Override
+    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        // Disable animations of preference changes.
+        getListView().setItemAnimator(null);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.clear();
+        mMenu = menu;
+        inflater.inflate(R.menu.save_password_preferences_action_bar_menu, menu);
+        menu.findItem(R.id.export_passwords).setVisible(ExportFlow.providesPasswordExport());
+        menu.findItem(R.id.export_passwords).setEnabled(false);
+        mSearchItem = menu.findItem(R.id.menu_id_search);
+        mSearchItem.setVisible(true);
+        mHelpItem = menu.findItem(R.id.menu_id_targeted_help);
+        mHelpItem.setVisible(false);
+        SearchUtils.initializeSearchView(
+                mSearchItem, mSearchQuery, getActivity(), this::filterPasswords);
+    }
+
+    @Override
+    public void onPrepareOptionsMenu(Menu menu) {
+        menu.findItem(R.id.export_passwords).setEnabled(!mNoPasswords && !mExportFlow.isActive());
+        super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        int id = item.getItemId();
+        if (id == R.id.export_passwords) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    mExportFlow.getExportEventHistogramName(),
+                    ExportFlow.PasswordExportEvent.EXPORT_OPTION_SELECTED,
+                    ExportFlow.PasswordExportEvent.COUNT);
+            mExportFlow.startExporting();
+            return true;
+        }
+        if (SearchUtils.handleSearchNavigation(item, mSearchItem, mSearchQuery, getActivity())) {
+            filterPasswords(null);
+            return true;
+        }
+        if (id == R.id.menu_id_targeted_help) {
+            getHelpAndFeedbackLauncher()
+                    .show(getActivity(), getString(R.string.help_context_passwords), null);
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    private void filterPasswords(String query) {
+        mSearchQuery = query;
+        mHelpItem.setShowAsAction(
+                mSearchQuery == null
+                        ? MenuItem.SHOW_AS_ACTION_IF_ROOM
+                        : MenuItem.SHOW_AS_ACTION_NEVER);
+        rebuildPasswordLists();
+    }
+
+    /** Empty screen message when no passwords or exceptions are stored. */
+    private void displayEmptyScreenMessage() {
+        TextMessagePreference emptyView = new TextMessagePreference(getStyledContext(), null);
+        emptyView.setSummary(R.string.saved_passwords_none_text);
+        emptyView.setKey(PREF_KEY_SAVED_PASSWORDS_NO_TEXT);
+        emptyView.setOrder(ORDER_SAVED_PASSWORDS_NO_TEXT);
+        emptyView.setDividerAllowedAbove(false);
+        emptyView.setDividerAllowedBelow(false);
+        getPreferenceScreen().addPreference(emptyView);
+    }
+
+    /** Include a message when there's no match. */
+    private void displayPasswordNoResultScreenMessage() {
+        Preference noResultView = new Preference(getStyledContext());
+        noResultView.setLayoutResource(R.layout.password_no_result);
+        noResultView.setSelectable(false);
+        getPreferenceScreen().addPreference(noResultView);
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+        ReauthenticationManager.resetLastReauth();
+    }
+
+    void rebuildPasswordLists() {
+        mNoPasswords = false;
+        mNoPasswordExceptions = false;
+        getPreferenceScreen().removeAll();
+        if (mSearchQuery != null) {
+            // Only the filtered passwords and exceptions should be shown.
+            PasswordManagerHandlerProvider.getForProfile(getProfile())
+                    .getPasswordManagerHandler()
+                    .updatePasswordLists();
+            return;
+        }
+
+        createSavePasswordsSwitch();
+        if (shouldShowAutoSigninOption()) {
+            createAutoSignInCheckbox();
+        }
+
+        if (mTrustedVaultBannerState == TrustedVaultBannerState.OPTED_IN) {
+            createTrustedVaultBanner(
+                    R.string.android_trusted_vault_banner_sub_label_opted_in,
+                    this::openTrustedVaultInfoPage);
+        } else if (mTrustedVaultBannerState == TrustedVaultBannerState.OFFER_OPT_IN) {
+            createTrustedVaultBanner(
+                    R.string.android_trusted_vault_banner_sub_label_offer_opt_in,
+                    this::openTrustedVaultOptInDialog);
+        }
+        PasswordManagerHandlerProvider.getForProfile(getProfile())
+                .getPasswordManagerHandler()
+                .updatePasswordLists();
+    }
+
+    private boolean shouldShowAutoSigninOption() {
+        return !BuildInfo.getInstance().isAutomotive;
+    }
+
+    /**
+     * Removes the UI displaying the list of saved passwords or exceptions.
+     * @param preferenceCategoryKey The key string identifying the PreferenceCategory to be removed.
+     */
+    private void resetList(String preferenceCategoryKey) {
+        PreferenceCategory profileCategory =
+                (PreferenceCategory) getPreferenceScreen().findPreference(preferenceCategoryKey);
+        if (profileCategory != null) {
+            profileCategory.removeAll();
+            getPreferenceScreen().removePreference(profileCategory);
+        }
+    }
+
+    /** Removes the message informing the user that there are no saved entries to display. */
+    private void resetNoEntriesTextMessage() {
+        Preference message = getPreferenceScreen().findPreference(PREF_KEY_SAVED_PASSWORDS_NO_TEXT);
+        if (message != null) {
+            getPreferenceScreen().removePreference(message);
+        }
+    }
+
+    @Override
+    public void passwordListAvailable(int count) {
+        resetList(PREF_KEY_CATEGORY_SAVED_PASSWORDS);
+        resetNoEntriesTextMessage();
+
+        mNoPasswords = count == 0;
+        if (mNoPasswords) {
+            if (mNoPasswordExceptions) displayEmptyScreenMessage();
+            return;
+        }
+
+        displayManageAccountLink();
+
+        PreferenceGroup passwordParent;
+        if (mSearchQuery == null) {
+            PreferenceCategory profileCategory = new PreferenceCategory(getStyledContext());
+            profileCategory.setKey(PREF_KEY_CATEGORY_SAVED_PASSWORDS);
+            profileCategory.setTitle(R.string.password_list_title);
+            profileCategory.setOrder(ORDER_SAVED_PASSWORDS);
+            getPreferenceScreen().addPreference(profileCategory);
+            passwordParent = profileCategory;
+        } else {
+            passwordParent = getPreferenceScreen();
+        }
+        for (int i = 0; i < count; i++) {
+            SavedPasswordEntry saved =
+                    PasswordManagerHandlerProvider.getForProfile(getProfile())
+                            .getPasswordManagerHandler()
+                            .getSavedPasswordEntry(i);
+            String url = saved.getUrl();
+            String name = saved.getUserName();
+            String password = saved.getPassword();
+            if (shouldBeFiltered(url, name)) {
+                continue; // The current password won't show with the active filter, try the next.
+            }
+            Preference preference = new Preference(getStyledContext());
+            preference.setTitle(url);
+            preference.setOnPreferenceClickListener(this);
+            preference.setSummary(name);
+            Bundle args = preference.getExtras();
+            args.putString(PASSWORD_LIST_NAME, name);
+            args.putString(PASSWORD_LIST_URL, url);
+            args.putString(PASSWORD_LIST_PASSWORD, password);
+            args.putInt(PASSWORD_LIST_ID, i);
+            passwordParent.addPreference(preference);
+        }
+        mNoPasswords = passwordParent.getPreferenceCount() == 0;
+        if (mMenu != null) {
+            MenuItem menuItem = mMenu.findItem(R.id.export_passwords);
+            if (menuItem != null) {
+                menuItem.setEnabled(!mNoPasswords && !mExportFlow.isActive());
+            }
+        }
+        if (mNoPasswords) {
+            if (count == 0) displayEmptyScreenMessage(); // Show if the list was already empty.
+            if (mSearchQuery == null) {
+                // If not searching, the category needs to be removed again.
+                getPreferenceScreen().removePreference(passwordParent);
+            } else {
+                displayPasswordNoResultScreenMessage();
+                getView()
+                        .announceForAccessibility(
+                                getString(R.string.accessible_find_in_page_no_results));
+            }
+        }
+    }
+
+    /**
+     * Returns true if there is a search query that requires the exclusion of an entry based on
+     * the passed url or name.
+     * @param url the visible URL of the entry to check. May be empty but must not be null.
+     * @param name the visible user name of the entry to check. May be empty but must not be null.
+     * @return Returns whether the entry with the passed url and name should be filtered.
+     */
+    private boolean shouldBeFiltered(final String url, final String name) {
+        if (mSearchQuery == null) {
+            return false;
+        }
+        return !url.toLowerCase(Locale.ENGLISH).contains(mSearchQuery.toLowerCase(Locale.ENGLISH))
+                && !name.toLowerCase(Locale.getDefault())
+                        .contains(mSearchQuery.toLowerCase(Locale.getDefault()));
+    }
+
+    @Override
+    public void passwordExceptionListAvailable(int count) {
+        if (mSearchQuery != null) return; // Don't show exceptions if a search is ongoing.
+        resetList(PREF_KEY_CATEGORY_EXCEPTIONS);
+        resetNoEntriesTextMessage();
+
+        mNoPasswordExceptions = count == 0;
+        if (mNoPasswordExceptions) {
+            if (mNoPasswords) displayEmptyScreenMessage();
+            return;
+        }
+
+        displayManageAccountLink();
+
+        PreferenceCategory profileCategory = new PreferenceCategory(getStyledContext());
+        profileCategory.setKey(PREF_KEY_CATEGORY_EXCEPTIONS);
+        profileCategory.setTitle(R.string.section_saved_passwords_exceptions);
+        profileCategory.setOrder(ORDER_EXCEPTIONS);
+        getPreferenceScreen().addPreference(profileCategory);
+        for (int i = 0; i < count; i++) {
+            String exception =
+                    PasswordManagerHandlerProvider.getForProfile(getProfile())
+                            .getPasswordManagerHandler()
+                            .getSavedPasswordException(i);
+            Preference preference = new Preference(getStyledContext());
+            preference.setTitle(exception);
+            preference.setOnPreferenceClickListener(this);
+            Bundle args = preference.getExtras();
+            args.putString(PASSWORD_LIST_URL, exception);
+            args.putInt(PASSWORD_LIST_ID, i);
+            profileCategory.addPreference(preference);
+        }
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        rebuildPasswordLists();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mExportFlow.onResume();
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent intent) {
+        super.onActivityResult(requestCode, resultCode, intent);
+        if (requestCode != PASSWORD_EXPORT_INTENT_REQUEST_CODE) return;
+        if (resultCode != Activity.RESULT_OK) return;
+        if (intent == null || intent.getData() == null) return;
+
+        mExportFlow.savePasswordsToDownloads(intent.getData());
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        mExportFlow.onSaveInstanceState(outState);
+        if (mSearchQuery != null) {
+            outState.putString(SAVED_STATE_SEARCH_QUERY, mSearchQuery);
+        }
+        outState.putInt(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER, mManagePasswordsReferrer);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        if (SyncServiceFactory.getForProfile(getProfile()) != null) {
+            SyncServiceFactory.getForProfile(getProfile()).removeSyncStateChangedListener(this);
+        }
+        // The component should only be destroyed when the activity has been closed by the user
+        // (e.g. by pressing on the back button) and not when the activity is temporarily destroyed
+        // by the system.
+        if (getActivity().isFinishing()) {
+            PasswordManagerHandlerProvider.getForProfile(getProfile()).removeObserver(this);
+        }
+    }
+
+    /**
+     *  Preference was clicked. Either navigate to manage account site or launch the PasswordEditor
+     *  depending on which preference it was.
+     */
+    @Override
+    public boolean onPreferenceClick(Preference preference) {
+        if (preference == mLinkPref) {
+            Intent intent =
+                    new Intent(
+                            Intent.ACTION_VIEW, Uri.parse(PasswordUiView.getAccountDashboardURL()));
+            intent.setPackage(getActivity().getPackageName());
+            getActivity().startActivity(intent);
+        } else {
+            boolean isBlockedCredential =
+                    !preference.getExtras().containsKey(PasswordSettings.PASSWORD_LIST_NAME);
+            PasswordManagerHandlerProvider.getForProfile(getProfile())
+                    .getPasswordManagerHandler()
+                    .showPasswordEntryEditingView(
+                            getActivity(),
+                            preference.getExtras().getInt(PasswordSettings.PASSWORD_LIST_ID),
+                            isBlockedCredential);
+        }
+        return true;
+    }
+
+    private void createSavePasswordsSwitch() {
+        ChromeSwitchPreference savePasswordsSwitch =
+                new ChromeSwitchPreference(getStyledContext(), null);
+        savePasswordsSwitch.setKey(PREF_SAVE_PASSWORDS_SWITCH);
+        savePasswordsSwitch.setTitle(R.string.password_settings_save_passwords);
+        savePasswordsSwitch.setOrder(ORDER_SWITCH);
+        savePasswordsSwitch.setSummaryOn(R.string.text_on);
+        savePasswordsSwitch.setSummaryOff(R.string.text_off);
+        savePasswordsSwitch.setOnPreferenceChangeListener(
+                (preference, newValue) -> {
+                    getPrefService()
+                            .setBoolean(Pref.CREDENTIALS_ENABLE_SERVICE, (boolean) newValue);
+                    RecordHistogram.recordBooleanHistogram(
+                            "PasswordManager.Settings.ToggleOfferToSavePasswords",
+                            (boolean) newValue);
+                    // TODO(http://crbug.com/1371422): Remove method and manage evictions from
+                    // native code as this is covered by chrome://password-manager-internals page.
+                    if ((boolean) newValue) {
+                        PasswordManagerHelper.getForProfile(getProfile()).resetUpmUnenrollment();
+                    }
+                    return true;
+                });
+        savePasswordsSwitch.setManagedPreferenceDelegate(
+                new ChromeManagedPreferenceDelegate(getProfile()) {
+                    @Override
+                    public boolean isPreferenceControlledByPolicy(Preference preference) {
+                        return getPrefService()
+                                .isManagedPreference(Pref.CREDENTIALS_ENABLE_SERVICE);
+                    }
+                });
+
+        getPreferenceScreen().addPreference(savePasswordsSwitch);
+
+        // Note: setting the switch state before the preference is added to the screen results in
+        // some odd behavior where the switch state doesn't always match the internal enabled state
+        // (e.g. the switch will say "On" when save passwords is really turned off), so
+        // .setChecked() should be called after .addPreference()
+        savePasswordsSwitch.setChecked(
+                getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_SERVICE));
+    }
+
+    private void createAutoSignInCheckbox() {
+        ChromeSwitchPreference autoSignInSwitch =
+                new ChromeSwitchPreference(getStyledContext(), null);
+        autoSignInSwitch.setKey(PREF_AUTOSIGNIN_SWITCH);
+        autoSignInSwitch.setTitle(R.string.passwords_auto_signin_title);
+        autoSignInSwitch.setOrder(ORDER_AUTO_SIGNIN_CHECKBOX);
+        autoSignInSwitch.setSummary(R.string.passwords_auto_signin_description);
+        autoSignInSwitch.setOnPreferenceChangeListener(
+                (preference, newValue) -> {
+                    getPrefService()
+                            .setBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN, (boolean) newValue);
+                    RecordHistogram.recordBooleanHistogram(
+                            "PasswordManager.Settings.ToggleAutoSignIn", (boolean) newValue);
+                    return true;
+                });
+        autoSignInSwitch.setManagedPreferenceDelegate(
+                new ChromeManagedPreferenceDelegate(getProfile()) {
+                    @Override
+                    public boolean isPreferenceControlledByPolicy(Preference preference) {
+                        return getPrefService()
+                                .isManagedPreference(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN);
+                    }
+                });
+        getPreferenceScreen().addPreference(autoSignInSwitch);
+        autoSignInSwitch.setChecked(
+                getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN));
+    }
+
+    private void createCheckPasswords() {
+        ChromeBasePreference checkPasswords = new ChromeBasePreference(getStyledContext());
+        checkPasswords.setKey(PREF_CHECK_PASSWORDS);
+        checkPasswords.setTitle(R.string.passwords_check_title);
+        checkPasswords.setOrder(ORDER_CHECK_PASSWORDS);
+        checkPasswords.setSummary(R.string.passwords_check_description);
+        // Add a listener which launches a settings page for the leak password check
+        checkPasswords.setOnPreferenceClickListener(
+                preference -> {
+                    PasswordCheck passwordCheck = PasswordCheckFactory.getOrCreate();
+                    passwordCheck.showUi(
+                            getStyledContext(), PasswordCheckReferrer.PASSWORD_SETTINGS);
+                    // Return true to notify the click was handled.
+                    return true;
+                });
+        getPreferenceScreen().addPreference(checkPasswords);
+    }
+
+    private void createTrustedVaultBanner(
+            @StringRes int subLabel, Preference.OnPreferenceClickListener listener) {
+        ChromeBasePreference trustedVaultBanner = new ChromeBasePreference(getStyledContext());
+        trustedVaultBanner.setKey(PREF_TRUSTED_VAULT_BANNER);
+        trustedVaultBanner.setTitle(R.string.android_trusted_vault_banner_label);
+        trustedVaultBanner.setOrder(ORDER_TRUSTED_VAULT_BANNER);
+        trustedVaultBanner.setSummary(subLabel);
+        trustedVaultBanner.setOnPreferenceClickListener(listener);
+        getPreferenceScreen().addPreference(trustedVaultBanner);
+    }
+
+    private void displayManageAccountLink() {
+        SyncService syncService = SyncServiceFactory.getForProfile(getProfile());
+        if (syncService == null || !syncService.isEngineInitialized()) {
+            return;
+        }
+        if (!PasswordManagerHelper.isSyncingPasswordsWithNoCustomPassphrase(syncService)) {
+            return;
+        }
+        if (mSearchQuery != null && !mNoPasswords) {
+            return; // Don't add the Manage Account link if there is a search going on.
+        }
+        if (getPreferenceScreen().findPreference(PREF_KEY_MANAGE_ACCOUNT_LINK) != null) {
+            return; // Don't add the Manage Account link if it's present.
+        }
+        if (mLinkPref != null) {
+            // If we created the link before, reuse it.
+            getPreferenceScreen().addPreference(mLinkPref);
+            return;
+        }
+        ForegroundColorSpan colorSpan =
+                new ForegroundColorSpan(SemanticColorUtils.getDefaultTextColorLink(getContext()));
+        SpannableString title =
+                SpanApplier.applySpans(
+                        getString(R.string.manage_passwords_text),
+                        new SpanApplier.SpanInfo("<link>", "</link>", colorSpan));
+        mLinkPref = new ChromeBasePreference(getStyledContext());
+        mLinkPref.setKey(PREF_KEY_MANAGE_ACCOUNT_LINK);
+        mLinkPref.setTitle(title);
+        mLinkPref.setOnPreferenceClickListener(this);
+        mLinkPref.setOrder(ORDER_MANAGE_ACCOUNT_LINK);
+        getPreferenceScreen().addPreference(mLinkPref);
+    }
+
+    private Context getStyledContext() {
+        return getPreferenceManager().getContext();
+    }
+
+    private PrefService getPrefService() {
+        return UserPrefs.get(getProfile());
+    }
+
+    @Override
+    public void syncStateChanged() {
+        final @TrustedVaultBannerState int oldTrustedVaultBannerState = mTrustedVaultBannerState;
+        computeTrustedVaultBannerState();
+        if (oldTrustedVaultBannerState != mTrustedVaultBannerState) {
+            rebuildPasswordLists();
+        }
+    }
+
+    private void computeTrustedVaultBannerState() {
+        final SyncService syncService = SyncServiceFactory.getForProfile(getProfile());
+        if (syncService == null) {
+            mTrustedVaultBannerState = TrustedVaultBannerState.NOT_SHOWN;
+            return;
+        }
+        if (!syncService.isEngineInitialized()) {
+            // Can't call getPassphraseType() yet.
+            mTrustedVaultBannerState = TrustedVaultBannerState.NOT_SHOWN;
+            return;
+        }
+        if (syncService.getPassphraseType() == PassphraseType.TRUSTED_VAULT_PASSPHRASE) {
+            mTrustedVaultBannerState = TrustedVaultBannerState.OPTED_IN;
+            return;
+        }
+        if (syncService.shouldOfferTrustedVaultOptIn()) {
+            mTrustedVaultBannerState = TrustedVaultBannerState.OFFER_OPT_IN;
+            return;
+        }
+        mTrustedVaultBannerState = TrustedVaultBannerState.NOT_SHOWN;
+    }
+
+    private boolean openTrustedVaultOptInDialog(Preference unused) {
+        assert SyncServiceFactory.getForProfile(getProfile()) != null;
+        CoreAccountInfo accountInfo =
+                SyncServiceFactory.getForProfile(getProfile()).getAccountInfo();
+        assert accountInfo != null;
+        SyncSettingsUtils.openTrustedVaultOptInDialog(
+                this, accountInfo, REQUEST_CODE_TRUSTED_VAULT_OPT_IN);
+        // Return true to notify the click was handled.
+        return true;
+    }
+
+    private boolean openTrustedVaultInfoPage(Preference unused) {
+        Intent intent =
+                new Intent(
+                        Intent.ACTION_VIEW,
+                        Uri.parse(PasswordUiView.getTrustedVaultLearnMoreURL()));
+        intent.setPackage(getActivity().getPackageName());
+        getActivity().startActivity(intent);
+        // Return true to notify the click was handled.
+        return true;
+    }
+
+    Menu getMenuForTesting() {
+        return mMenu;
+    }
+
+    Toolbar getToolbarForTesting() {
+        return getActivity().findViewById(R.id.action_bar);
+    }
+
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
+}
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
@@ -473,16 +473,16 @@ public class MainSettings extends ChromeBaseSettingsFragment
                                         getActivity()));
         PasswordsPreference passwordsPreference = findPreference(PREF_PASSWORDS);
         passwordsPreference.setProfile(getProfile());
-        passwordsPreference.setOnPreferenceClickListener(
-                preference -> {
-                    PasswordManagerLauncher.showPasswordSettings(
-                            getActivity(),
-                            getProfile(),
-                            ManagePasswordsReferrer.CHROME_SETTINGS,
-                            mModalDialogManagerSupplier,
-                            /* managePasskeys= */ false);
-                    return true;
-                });
+        // passwordsPreference.setOnPreferenceClickListener(
+        //         preference -> {
+        //             PasswordManagerLauncher.showPasswordSettings(
+        //                     getActivity(),
+        //                     getProfile(),
+        //                     ManagePasswordsReferrer.CHROME_SETTINGS,
+        //                     mModalDialogManagerSupplier,
+        //                     /* managePasskeys= */ false);
+        //             return true;
+        //         });
 
         // This is temporary code needed for migrating people to UPM. With UPM there is no
         // longer passwords setting page in Chrome, so we need to ask users to export their
diff --git a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java
--- a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java
+++ b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java
@@ -131,6 +131,7 @@ public class AutofillClientProviderUtils {
 
     @CalledByNative
     public static void setAutofillOptionsDeepLinkPref(boolean featureOn) {
+        featureOn = false;
         Editor editor =
                 ContextUtils.getApplicationContext()
                         .getSharedPreferences(
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java
new file mode 100644
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java
@@ -0,0 +1,83 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.content.Context;
+
+import org.chromium.base.Callback;
+import org.chromium.base.IntStringCallback;
+import org.chromium.build.annotations.NullMarked;
+
+/**
+ * Interface for retrieving passwords and password exceptions (websites for which Chrome should not
+ * save password) from native code.
+ */
+@NullMarked
+public interface PasswordManagerHandler {
+    /** Called to insert a password entry into the password store. */
+    public void insertPasswordEntryForTesting(String origin, String username, String password);
+
+    /** Called to start fetching password and exception lists. */
+    void updatePasswordLists();
+
+    /**
+     * Get the saved password entry at index.
+     *
+     * @param index Index of Password.
+     * @return SavedPasswordEntry at index.
+     */
+    SavedPasswordEntry getSavedPasswordEntry(int index);
+
+    /**
+     * Get saved password exception at index.
+     *
+     * @param index of exception
+     * @return Origin of password exception.
+     */
+    String getSavedPasswordException(int index);
+
+    /**
+     * Remove saved password entry at index.
+     *
+     * @param index of password entry to remove.
+     */
+    void removeSavedPasswordEntry(int index);
+
+    /**
+     * Remove saved exception entry at index.
+     *
+     * @param index of exception entry.
+     */
+    void removeSavedPasswordException(int index);
+
+    /**
+     * Trigger serializing the saved passwords in the background.
+     *
+     * @param targetPath is the file to which the serialized passwords should be written.
+     * @param successCallback is called on successful completion, with the count of the serialized
+     * passwords and the path to the file containing them as argument.
+     * @param errorCallback is called on failure, with the error message as argument.
+     */
+    void serializePasswords(
+            String targetPath, IntStringCallback successCallback, Callback<String> errorCallback);
+
+    /**
+     * Show the UI that allows to edit saved credentials.
+     *
+     * @param context the current Activity to launch the edit view from, or an application context
+     *     if no Activity is available.
+     * @param index the index of the password entry to edit
+     * @param isBlockedCredential whether this credential is blocked for saving
+     */
+    void showPasswordEntryEditingView(Context context, int index, boolean isBlockedCredential);
+
+    /**
+     * Calls C++ to check whether the PasswordManagerHandler is still waiting for the passwords to
+     * be fetched from the password store.
+     *
+     * @return Returns true if the request to fetch the passwords is still pending.
+     */
+    boolean isWaitingForPasswordStore();
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java
new file mode 100644
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java
@@ -0,0 +1,215 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.content.Context;
+
+import org.jni_zero.CalledByNative;
+import org.jni_zero.JniType;
+import org.jni_zero.NativeMethods;
+
+import org.chromium.base.Callback;
+import org.chromium.base.IntStringCallback;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.chrome.browser.profiles.Profile;
+
+/**
+ * Production implementation of PasswordManagerHandler, making calls to native C++ code to retrieve
+ * the data.
+ */
+@NullMarked
+public final class PasswordUiView implements PasswordManagerHandler {
+    @CalledByNative
+    private static SavedPasswordEntry createSavedPasswordEntry(
+            @JniType("std::string") String url,
+            @JniType("std::u16string") String name,
+            @JniType("std::u16string") String password) {
+        return new SavedPasswordEntry(url, name, password);
+    }
+
+    // Pointer to native implementation, set to 0 in destroy().
+    private long mNativePasswordUiViewAndroid;
+
+    // This class has exactly one observer, set on construction and expected to last at least as
+    // long as this object (a good candidate is the owner of this object).
+    private final PasswordListObserver mObserver;
+
+    /**
+     * Constructor creates the native object as well. Callers should call destroy() after usage.
+     *
+     * @param observer The only observer.
+     * @param profile The {@link Profile} associated with these passwords.
+     */
+    public PasswordUiView(PasswordListObserver observer, Profile profile) {
+        mNativePasswordUiViewAndroid = PasswordUiViewJni.get().init(PasswordUiView.this, profile);
+        mObserver = observer;
+    }
+
+    @CalledByNative
+    private void passwordListAvailable(int count) {
+        mObserver.passwordListAvailable(count);
+    }
+
+    @CalledByNative
+    private void passwordExceptionListAvailable(int count) {
+        mObserver.passwordExceptionListAvailable(count);
+    }
+
+    @Override
+    public void insertPasswordEntryForTesting(String origin, String username, String password) {
+        PasswordUiViewJni.get()
+                .insertPasswordEntryForTesting(
+                        mNativePasswordUiViewAndroid, origin, username, password);
+    }
+
+    // Calls native to refresh password and exception lists. The native code calls back into
+    // passwordListAvailable and passwordExceptionListAvailable.
+    @Override
+    public void updatePasswordLists() {
+        PasswordUiViewJni.get()
+                .updatePasswordLists(mNativePasswordUiViewAndroid, PasswordUiView.this);
+    }
+
+    @Override
+    public SavedPasswordEntry getSavedPasswordEntry(int index) {
+        return PasswordUiViewJni.get()
+                .getSavedPasswordEntry(mNativePasswordUiViewAndroid, PasswordUiView.this, index);
+    }
+
+    @Override
+    public String getSavedPasswordException(int index) {
+        return PasswordUiViewJni.get()
+                .getSavedPasswordException(
+                        mNativePasswordUiViewAndroid, PasswordUiView.this, index);
+    }
+
+    @Override
+    public void removeSavedPasswordEntry(int index) {
+        PasswordUiViewJni.get()
+                .handleRemoveSavedPasswordEntry(
+                        mNativePasswordUiViewAndroid, PasswordUiView.this, index);
+    }
+
+    @Override
+    public void removeSavedPasswordException(int index) {
+        PasswordUiViewJni.get()
+                .handleRemoveSavedPasswordException(
+                        mNativePasswordUiViewAndroid, PasswordUiView.this, index);
+    }
+
+    @Override
+    public void serializePasswords(
+            String targetPath, IntStringCallback successCallback, Callback<String> errorCallback) {
+        PasswordUiViewJni.get()
+                .handleSerializePasswords(
+                        mNativePasswordUiViewAndroid,
+                        PasswordUiView.this,
+                        targetPath,
+                        successCallback,
+                        errorCallback);
+    }
+
+    @Override
+    public void showPasswordEntryEditingView(
+            Context context, int index, boolean isBlockedCredential) {
+        if (isBlockedCredential) {
+            PasswordUiViewJni.get()
+                    .handleShowBlockedCredentialView(
+                            mNativePasswordUiViewAndroid, context, index, PasswordUiView.this);
+            return;
+        }
+        PasswordUiViewJni.get()
+                .handleShowPasswordEntryEditingView(
+                        mNativePasswordUiViewAndroid, context, index, PasswordUiView.this);
+    }
+
+    /**
+     * Returns the URL for the website for managing one's passwords without the need to use Chrome
+     * with the user's profile signed in.
+     *
+     * @return The string with the URL.
+     */
+    public static String getAccountDashboardURL() {
+        return PasswordUiViewJni.get().getAccountDashboardURL();
+    }
+
+    /**
+     * Returns the URL of the help center article about trusted vault encryption.
+     *
+     * @return The string with the URL.
+     */
+    public static String getTrustedVaultLearnMoreURL() {
+        return PasswordUiViewJni.get().getTrustedVaultLearnMoreURL();
+    }
+
+    @Override
+    public boolean isWaitingForPasswordStore() {
+        return PasswordUiViewJni.get()
+                .isWaitingForPasswordStore(mNativePasswordUiViewAndroid, PasswordUiView.this);
+    }
+
+    /** Destroy the native object. */
+    public void destroy() {
+        if (mNativePasswordUiViewAndroid != 0) {
+            PasswordUiViewJni.get().destroy(mNativePasswordUiViewAndroid, PasswordUiView.this);
+            mNativePasswordUiViewAndroid = 0;
+        }
+    }
+
+    @NativeMethods
+    interface Natives {
+        long init(PasswordUiView caller, @JniType("Profile*") Profile profile);
+
+        void insertPasswordEntryForTesting(
+                long nativePasswordUiViewAndroid,
+                @JniType("std::u16string") String origin,
+                @JniType("std::u16string") String username,
+                @JniType("std::u16string") String password);
+
+        void updatePasswordLists(long nativePasswordUiViewAndroid, PasswordUiView caller);
+
+        SavedPasswordEntry getSavedPasswordEntry(
+                long nativePasswordUiViewAndroid, PasswordUiView caller, int index);
+
+        @JniType("std::string")
+        String getSavedPasswordException(
+                long nativePasswordUiViewAndroid, PasswordUiView caller, int index);
+
+        void handleRemoveSavedPasswordEntry(
+                long nativePasswordUiViewAndroid, PasswordUiView caller, int index);
+
+        void handleRemoveSavedPasswordException(
+                long nativePasswordUiViewAndroid, PasswordUiView caller, int index);
+
+        @JniType("std::string")
+        String getAccountDashboardURL();
+
+        @JniType("std::string")
+        String getTrustedVaultLearnMoreURL();
+
+        boolean isWaitingForPasswordStore(long nativePasswordUiViewAndroid, PasswordUiView caller);
+
+        void destroy(long nativePasswordUiViewAndroid, PasswordUiView caller);
+
+        void handleSerializePasswords(
+                long nativePasswordUiViewAndroid,
+                PasswordUiView caller,
+                @JniType("std::string") String targetPath,
+                IntStringCallback successCallback,
+                Callback<String> errorCallback);
+
+        void handleShowPasswordEntryEditingView(
+                long nativePasswordUiViewAndroid,
+                Context context,
+                int index,
+                PasswordUiView caller);
+
+        void handleShowBlockedCredentialView(
+                long nativePasswordUiViewAndroid,
+                Context context,
+                int index,
+                PasswordUiView caller);
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreference.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreference.java
--- a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreference.java
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreference.java
@@ -87,6 +87,7 @@ public class PasswordsPreference extends ChromeBasePreference implements Profile
     }
 
     private void setUpPostDeprecationWarning(PreferenceViewHolder holder, PrefService prefService) {
+        if ((true)) return;
         assert mProfile != null : "Profile is not set!";
 
         boolean isPasswordManagerAvailable =
diff --git a/chrome/browser/password_manager/android/login_db_deprecation_runner_factory.cc b/chrome/browser/password_manager/android/login_db_deprecation_runner_factory.cc
--- a/chrome/browser/password_manager/android/login_db_deprecation_runner_factory.cc
+++ b/chrome/browser/password_manager/android/login_db_deprecation_runner_factory.cc
@@ -39,7 +39,7 @@ std::unique_ptr<KeyedService>
 LoginDbDeprecationRunnerFactory::BuildServiceInstanceForBrowserContext(
     content::BrowserContext* context) const {
 #if BUILDFLAG(USE_LOGIN_DATABASE_AS_BACKEND)
-  return nullptr;
+  if ((true)) return nullptr;
 #else
   Profile* profile = Profile::FromBrowserContext(context);
   PrefService* prefs = profile->GetPrefs();
diff --git a/chrome/browser/password_manager/android/password_manager_android_util.cc b/chrome/browser/password_manager/android/password_manager_android_util.cc
--- a/chrome/browser/password_manager/android/password_manager_android_util.cc
+++ b/chrome/browser/password_manager/android/password_manager_android_util.cc
@@ -31,6 +31,7 @@ namespace password_manager_android_util {
 namespace {
 
 bool HasMinGmsVersionForFullUpmSupport() {
+  if ((true)) return false;
   std::string gms_version_str =
       base::android::BuildInfo::GetInstance()->gms_version_code();
   int gms_version = 0;
diff --git a/chrome/browser/password_manager/android/password_ui_view_android.cc b/chrome/browser/password_manager/android/password_ui_view_android.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/password_manager/android/password_ui_view_android.cc
@@ -0,0 +1,379 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/password_manager/android/password_ui_view_android.h"
+
+#include <algorithm>
+#include <memory>
+#include <vector>
+
+#include "base/android/callback_android.h"
+#include "base/android/int_string_callback.h"
+#include "base/android/jni_string.h"
+#include "base/android/jni_weak_ref.h"
+#include "base/android/scoped_java_ref.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/functional/bind.h"
+#include "base/functional/callback_helpers.h"
+#include "base/logging.h"
+#include "base/metrics/field_trial.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/user_metrics.h"
+#include "base/metrics/user_metrics_action.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/password_manager/android/local_passwords_migration_warning_util.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/password_manager/core/browser/export/password_csv_writer.h"
+#include "components/password_manager/core/browser/form_parsing/form_data_parser.h"
+#include "components/password_manager/core/browser/leak_detection/leak_detection_check_impl.h"
+#include "components/password_manager/core/browser/password_form.h"
+#include "components/password_manager/core/browser/password_ui_utils.h"
+#include "components/password_manager/core/browser/ui/credential_provider_interface.h"
+#include "components/password_manager/core/browser/ui/credential_ui_entry.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "url/gurl.h"
+
+// Must come after other includes, because FromJniType() uses Profile.
+#include "chrome/browser/password_manager/android/jni_headers/PasswordUiView_jni.h"
+
+namespace {
+
+using base::android::JavaParamRef;
+using base::android::JavaRef;
+using base::android::ScopedJavaLocalRef;
+using IsInsecureCredential = CredentialEditBridge::IsInsecureCredential;
+
+PasswordUiViewAndroid::SerializationResult SerializePasswords(
+    const base::FilePath& target_directory,
+    std::vector<password_manager::CredentialUIEntry> credentials) {
+  // The UI should not trigger serialization if there are no passwords.
+  base::UmaHistogramBoolean(
+      "PasswordManager.ExportAndroid.MoreThanZeroPasswords",
+      credentials.size() > 0);
+
+  // Creating a file will block the execution on I/O.
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::WILL_BLOCK);
+
+  // Ensure that the target directory exists.
+  base::File::Error error = base::File::FILE_OK;
+  if (!base::CreateDirectoryAndGetError(target_directory, &error)) {
+    base::UmaHistogramExactLinear(
+        "PasswordManager.ExportAndroid.CreateDirectoryError", -error,
+        -base::File::Error::FILE_ERROR_MAX);
+    return {0, std::string(), base::File::ErrorToString(error)};
+  }
+
+  // Create a temporary file in the target directory to hold the serialized
+  // passwords.
+  base::FilePath export_file;
+  if (!base::CreateTemporaryFileInDir(target_directory, &export_file)) {
+    logging::SystemErrorCode error_code = logging::GetLastSystemErrorCode();
+    base::UmaHistogramExactLinear(
+        "PasswordManager.ExportAndroid.CreateTempFileError",
+        -base::File::OSErrorToFileError(error_code),
+        -base::File::Error::FILE_ERROR_MAX);
+    return {0, std::string(), logging::SystemErrorCodeToString(error_code)};
+  }
+
+  // Write the serialized data in CSV.
+  std::string data =
+      password_manager::PasswordCSVWriter::SerializePasswords(credentials);
+  if (!base::WriteFile(export_file, data)) {
+    logging::SystemErrorCode error_code = logging::GetLastSystemErrorCode();
+    base::UmaHistogramExactLinear(
+        "PasswordManager.ExportAndroid.WriteToTempFileError",
+        -base::File::OSErrorToFileError(error_code),
+        -base::File::Error::FILE_ERROR_MAX);
+    return {0, std::string(), logging::SystemErrorCodeToString(error_code)};
+  }
+
+  return {static_cast<int>(credentials.size()), export_file.value(),
+          std::string()};
+}
+
+}  // namespace
+
+PasswordUiViewAndroid::PasswordUiViewAndroid(
+    JNIEnv* env,
+    const jni_zero::JavaRef<jobject>& obj,
+    Profile* profile)
+    : profile_(profile),
+      profile_store_(ProfilePasswordStoreFactory::GetForProfile(
+          profile,
+          ServiceAccessType::EXPLICIT_ACCESS)),
+      saved_passwords_presenter_(
+          AffiliationServiceFactory::GetForProfile(profile),
+          profile_store_,
+          AccountPasswordStoreFactory::GetForProfile(
+              profile,
+              ServiceAccessType::EXPLICIT_ACCESS)),
+      weak_java_ui_controller_(env, obj) {
+  saved_passwords_presenter_.AddObserver(this);
+  saved_passwords_presenter_.Init();
+}
+
+PasswordUiViewAndroid::~PasswordUiViewAndroid() {
+  saved_passwords_presenter_.RemoveObserver(this);
+}
+
+void PasswordUiViewAndroid::Destroy(JNIEnv*, const JavaRef<jobject>&) {
+  switch (state_) {
+    case State::ALIVE:
+      delete this;
+      break;
+    case State::ALIVE_SERIALIZATION_PENDING:
+      // Postpone the deletion until the pending tasks are completed, so that
+      // the tasks do not attempt a use after free while reading data from
+      // |this|.
+      state_ = State::DELETION_PENDING;
+      break;
+    case State::DELETION_PENDING:
+      NOTREACHED();
+  }
+}
+
+void PasswordUiViewAndroid::InsertPasswordEntryForTesting(
+    JNIEnv* env,
+    const std::u16string& origin,
+    const std::u16string& username,
+    const std::u16string& password) {
+  password_manager::PasswordForm form;
+  form.url = GURL(origin);
+  form.signon_realm = password_manager::GetSignonRealm(form.url);
+  form.username_value = username;
+  form.password_value = password;
+
+  profile_store_->AddLogin(form);
+}
+
+void PasswordUiViewAndroid::UpdatePasswordLists(JNIEnv* env,
+                                                const JavaRef<jobject>&) {
+  DCHECK_EQ(State::ALIVE, state_);
+  UpdatePasswordLists();
+}
+
+ScopedJavaLocalRef<jobject> PasswordUiViewAndroid::GetSavedPasswordEntry(
+    JNIEnv* env,
+    const JavaRef<jobject>&,
+    int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= passwords_.size()) {
+    return Java_PasswordUiView_createSavedPasswordEntry(
+        env, std::string(), std::u16string(), std::u16string());
+  }
+  return Java_PasswordUiView_createSavedPasswordEntry(
+      env, password_manager::GetShownOrigin(passwords_[index]),
+      passwords_[index].username, passwords_[index].password);
+}
+
+std::string PasswordUiViewAndroid::GetSavedPasswordException(
+    JNIEnv* env,
+    const JavaRef<jobject>&,
+    int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= blocked_sites_.size()) {
+    return "";
+  }
+  return password_manager::GetShownOrigin(blocked_sites_[index]);
+}
+
+void PasswordUiViewAndroid::HandleRemoveSavedPasswordEntry(
+    JNIEnv* env,
+    const JavaRef<jobject>&,
+    int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= passwords_.size()) {
+    return;
+  }
+  if (saved_passwords_presenter_.RemoveCredential(passwords_[index])) {
+    base::RecordAction(
+        base::UserMetricsAction("PasswordManager_RemoveSavedPassword"));
+  }
+}
+
+void PasswordUiViewAndroid::HandleRemoveSavedPasswordException(
+    JNIEnv* env,
+    const JavaRef<jobject>&,
+    int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= passwords_.size()) {
+    return;
+  }
+  if (saved_passwords_presenter_.RemoveCredential(passwords_[index])) {
+    base::RecordAction(
+        base::UserMetricsAction("PasswordManager_RemovePasswordException"));
+  }
+}
+
+void PasswordUiViewAndroid::HandleSerializePasswords(
+    JNIEnv* env,
+    const JavaRef<jobject>&,
+    const std::string& java_target_directory,
+    const JavaRef<jobject>& success_callback,
+    const JavaRef<jobject>& error_callback) {
+  switch (state_) {
+    case State::ALIVE:
+      state_ = State::ALIVE_SERIALIZATION_PENDING;
+      break;
+    case State::ALIVE_SERIALIZATION_PENDING:
+      // The UI should not allow the user to re-request export before finishing
+      // or cancelling the pending one.
+      NOTREACHED();
+    case State::DELETION_PENDING:
+      // The Java part should not first request destroying of |this| and then
+      // ask |this| for serialized passwords.
+      NOTREACHED();
+  }
+  std::vector<password_manager::CredentialUIEntry> credentials =
+      saved_passwords_presenter_.GetSavedCredentials();
+  std::erase_if(credentials, [](const auto& credential) {
+    return credential.blocked_by_user;
+  });
+
+  // The tasks are posted with base::Unretained, because deletion is postponed
+  // until the reply arrives (look for the occurrences of DELETION_PENDING in
+  // this file). The background processing is not expected to take very long,
+  // but still long enough not to block the UI thread. The main concern here is
+  // not to avoid the background computation if |this| is about to be deleted
+  // but to simply avoid use after free from the background task runner.
+  base::ThreadPool::PostTaskAndReplyWithResult(
+      FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
+      base::BindOnce(&SerializePasswords, base::FilePath(java_target_directory),
+                     std::move(credentials)),
+      base::BindOnce(&PasswordUiViewAndroid::PostSerializedPasswords,
+                     base::Unretained(this),
+                     base::android::ScopedJavaGlobalRef<jobject>(
+                         env, success_callback.obj()),
+                     base::android::ScopedJavaGlobalRef<jobject>(
+                         env, error_callback.obj())));
+}
+
+void PasswordUiViewAndroid::HandleShowPasswordEntryEditingView(
+    JNIEnv* env,
+    const base::android::JavaRef<jobject>& context,
+    int index,
+    const JavaParamRef<jobject>& obj) {
+  if (static_cast<size_t>(index) >= passwords_.size() ||
+      credential_edit_bridge_) {
+    return;
+  }
+  bool is_using_account_store = passwords_[index].stored_in.contains(
+      password_manager::PasswordForm::Store::kAccountStore);
+  credential_edit_bridge_ = CredentialEditBridge::MaybeCreate(
+      passwords_[index], IsInsecureCredential(false),
+      GetUsernamesForRealm(saved_passwords_presenter_.GetSavedCredentials(),
+                           passwords_[index].GetFirstSignonRealm(),
+                           is_using_account_store),
+      &saved_passwords_presenter_,
+      base::BindOnce(&PasswordUiViewAndroid::OnEditUIDismissed,
+                     base::Unretained(this)),
+      context);
+}
+
+void PasswordUiViewAndroid::HandleShowBlockedCredentialView(
+    JNIEnv* env,
+    const base::android::JavaRef<jobject>& context,
+    int index,
+    const JavaParamRef<jobject>& obj) {
+  if (static_cast<size_t>(index) >= blocked_sites_.size() ||
+      credential_edit_bridge_) {
+    return;
+  }
+  credential_edit_bridge_ = CredentialEditBridge::MaybeCreate(
+      blocked_sites_[index], IsInsecureCredential(false),
+      std::vector<std::u16string>(), &saved_passwords_presenter_,
+      base::BindOnce(&PasswordUiViewAndroid::OnEditUIDismissed,
+                     base::Unretained(this)),
+      context);
+}
+
+void PasswordUiViewAndroid::OnEditUIDismissed() {
+  credential_edit_bridge_.reset();
+}
+
+std::string JNI_PasswordUiView_GetAccountDashboardURL(JNIEnv* env) {
+  return l10n_util::GetStringUTF8(IDS_PASSWORDS_WEB_LINK);
+}
+
+std::string JNI_PasswordUiView_GetTrustedVaultLearnMoreURL(JNIEnv* env) {
+  return chrome::kSyncTrustedVaultLearnMoreURL;
+}
+
+jboolean PasswordUiViewAndroid::IsWaitingForPasswordStore(
+    JNIEnv* env,
+    const base::android::JavaRef<jobject>&) {
+  return saved_passwords_presenter_.IsWaitingForPasswordStore();
+}
+
+// static
+static jlong JNI_PasswordUiView_Init(JNIEnv* env,
+                                     const JavaParamRef<jobject>& obj,
+                                     Profile* profile) {
+  PasswordUiViewAndroid* controller =
+      new PasswordUiViewAndroid(env, obj, profile);
+  return reinterpret_cast<intptr_t>(controller);
+}
+
+void PasswordUiViewAndroid::OnSavedPasswordsChanged(
+    const password_manager::PasswordStoreChangeList& changes) {
+  UpdatePasswordLists();
+}
+
+void PasswordUiViewAndroid::UpdatePasswordLists() {
+  passwords_.clear();
+  blocked_sites_.clear();
+  for (auto& credential : saved_passwords_presenter_.GetSavedCredentials()) {
+    if (credential.blocked_by_user) {
+      blocked_sites_.push_back(std::move(credential));
+    } else {
+      passwords_.push_back(std::move(credential));
+    }
+  }
+  JNIEnv* env = base::android::AttachCurrentThread();
+  ScopedJavaLocalRef<jobject> ui_controller = weak_java_ui_controller_.get(env);
+  if (!ui_controller.is_null()) {
+    Java_PasswordUiView_passwordListAvailable(
+        env, ui_controller, static_cast<int>(passwords_.size()));
+    Java_PasswordUiView_passwordExceptionListAvailable(
+        env, ui_controller, static_cast<int>(blocked_sites_.size()));
+  }
+}
+
+void PasswordUiViewAndroid::PostSerializedPasswords(
+    const base::android::JavaRef<jobject>& success_callback,
+    const base::android::JavaRef<jobject>& error_callback,
+    SerializationResult serialization_result) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  switch (state_) {
+    case State::ALIVE:
+      NOTREACHED();
+    case State::ALIVE_SERIALIZATION_PENDING: {
+      state_ = State::ALIVE;
+      if (export_target_for_testing_) {
+        *export_target_for_testing_ = serialization_result;
+      } else {
+        if (serialization_result.entries_count) {
+          base::android::RunIntStringCallbackAndroid(
+              success_callback, serialization_result.entries_count,
+              serialization_result.exported_file_path);
+        } else {
+          base::android::RunStringCallbackAndroid(error_callback,
+                                                  serialization_result.error);
+        }
+      }
+      break;
+    }
+    case State::DELETION_PENDING:
+      delete this;
+      break;
+  }
+}
diff --git a/chrome/browser/password_manager/android/password_ui_view_android.h b/chrome/browser/password_manager/android/password_ui_view_android.h
new file mode 100644
--- /dev/null
+++ b/chrome/browser/password_manager/android/password_ui_view_android.h
@@ -0,0 +1,178 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_PASSWORD_MANAGER_ANDROID_PASSWORD_UI_VIEW_ANDROID_H_
+#define CHROME_BROWSER_PASSWORD_MANAGER_ANDROID_PASSWORD_UI_VIEW_ANDROID_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/android/jni_weak_ref.h"
+#include "base/android/scoped_java_ref.h"
+#include "base/memory/raw_ptr.h"
+#include "chrome/browser/affiliations/affiliation_service_factory.h"
+#include "chrome/browser/password_entry_edit/android/credential_edit_bridge.h"
+#include "chrome/browser/password_manager/account_password_store_factory.h"
+#include "chrome/browser/password_manager/profile_password_store_factory.h"
+#include "chrome/browser/signin/identity_manager_factory.h"
+#include "components/password_manager/core/browser/password_store/password_store_consumer.h"
+#include "components/password_manager/core/browser/ui/saved_passwords_presenter.h"
+
+class Profile;
+
+namespace password_manager {
+class CredentialProviderInterface;
+}
+
+// PasswordUIView for Android, contains jni hooks that allows Android UI to
+// display passwords and route UI commands back to SavedPasswordsPresenter.
+class PasswordUiViewAndroid
+    : public password_manager::SavedPasswordsPresenter::Observer {
+ public:
+  // Result of transforming a vector of PasswordForms into their CSV
+  // description and writing that to disk.
+  struct SerializationResult {
+    // The number of password entries written. 0 if error encountered.
+    int entries_count;
+
+    // The path to the temporary file containing the serialized passwords. Empty
+    // if error encountered.
+    std::string exported_file_path;
+
+    // The error description recorded after the last write operation. Empty if
+    // no error encountered.
+    std::string error;
+  };
+
+  PasswordUiViewAndroid(JNIEnv* env,
+                        const jni_zero::JavaRef<jobject>& obj,
+                        Profile* profile);
+
+  PasswordUiViewAndroid(const PasswordUiViewAndroid&) = delete;
+  PasswordUiViewAndroid& operator=(const PasswordUiViewAndroid&) = delete;
+
+  ~PasswordUiViewAndroid() override;
+
+  // Calls from Java.
+  base::android::ScopedJavaLocalRef<jobject> GetSavedPasswordEntry(
+      JNIEnv* env,
+      const base::android::JavaRef<jobject>&,
+      int index);
+  std::string GetSavedPasswordException(JNIEnv* env,
+                                        const base::android::JavaRef<jobject>&,
+                                        int index);
+  void InsertPasswordEntryForTesting(JNIEnv* env,
+                                     const std::u16string& origin,
+                                     const std::u16string& username,
+                                     const std::u16string& password);
+  void UpdatePasswordLists(JNIEnv* env, const base::android::JavaRef<jobject>&);
+  void HandleRemoveSavedPasswordEntry(JNIEnv* env,
+                                      const base::android::JavaRef<jobject>&,
+                                      int index);
+  void HandleRemoveSavedPasswordException(
+      JNIEnv* env,
+      const base::android::JavaRef<jobject>&,
+      int index);
+  void HandleSerializePasswords(
+      JNIEnv* env,
+      const base::android::JavaRef<jobject>&,
+      const std::string& java_target_directory,
+      const base::android::JavaRef<jobject>& success_callback,
+      const base::android::JavaRef<jobject>& error_callback);
+  void HandleShowPasswordEntryEditingView(
+      JNIEnv* env,
+      const base::android::JavaRef<jobject>& context,
+      int index,
+      const base::android::JavaParamRef<jobject>& obj);
+  void HandleShowBlockedCredentialView(
+      JNIEnv* env,
+      const base::android::JavaRef<jobject>& context,
+      int index,
+      const base::android::JavaParamRef<jobject>& obj);
+  jboolean IsWaitingForPasswordStore(JNIEnv* env,
+                                     const base::android::JavaRef<jobject>&);
+  // Destroy the native implementation.
+  void Destroy(JNIEnv*, const base::android::JavaRef<jobject>&);
+
+  void OnEditUIDismissed();
+
+  void set_export_target_for_testing(
+      SerializationResult* export_target_for_testing) {
+    export_target_for_testing_ = export_target_for_testing;
+  }
+
+  void set_credential_provider_for_testing(
+      password_manager::CredentialProviderInterface* provider) {
+    credential_provider_for_testing_ = provider;
+  }
+
+ private:
+  // Possible states in the life of PasswordUiViewAndroid.
+  // ALIVE:
+  //   * Destroy was not called and no background tasks are pending.
+  //   * All data members can be used on the main task runner.
+  // ALIVE_SERIALIZATION_PENDING:
+  //   * Destroy was not called, password serialization task on another task
+  //     runner is running.
+  //   * All data members can be used on the main task runner, except for
+  //     |saved_passwords_presenter_| which can only be used inside
+  //     ObtainAndSerializePasswords, which is being run on a backend task
+  //     runner.
+  // DELETION_PENDING:
+  //   * Destroy() was called, a background task is pending and |this| should
+  //     be deleted once the tasks complete.
+  //   * This state should not be reached anywhere but in the completion call
+  //     of the pending task.
+  enum class State { ALIVE, ALIVE_SERIALIZATION_PENDING, DELETION_PENDING };
+
+  // password_manager::SavedPasswordsPresenter::Observer implementation.
+  void OnSavedPasswordsChanged(
+      const password_manager::PasswordStoreChangeList& changes) override;
+
+  void UpdatePasswordLists();
+
+  // Sends |serialization_result| to Java via |success_callback| or
+  // |error_callback|, depending on whether the result is a success or an error.
+  void PostSerializedPasswords(
+      const base::android::JavaRef<jobject>& success_callback,
+      const base::android::JavaRef<jobject>& error_callback,
+      SerializationResult serialization_result);
+
+  // The |state_| must only be accessed on the main task runner.
+  State state_ = State::ALIVE;
+
+  // If not null, PostSerializedPasswords will write the serialized passwords to
+  // |*export_target_for_testing_| instead of passing them to Java. This must
+  // remain null in production code.
+  raw_ptr<SerializationResult> export_target_for_testing_ = nullptr;
+
+  raw_ptr<Profile> profile_;
+
+  // Pointer to the password store, powering |saved_passwords_presenter_|.
+  scoped_refptr<password_manager::PasswordStoreInterface> profile_store_;
+
+  // Manages the list of saved passwords, including updates.
+  password_manager::SavedPasswordsPresenter saved_passwords_presenter_;
+
+  // Cached passwords and blocked sites.
+  std::vector<password_manager::CredentialUIEntry> passwords_;
+  std::vector<password_manager::CredentialUIEntry> blocked_sites_;
+
+  // If not null, passwords for exporting will be obtained from
+  // |*credential_provider_for_testing_|, otherwise from
+  // |saved_passwords_presenter_|. This must remain null in production code.
+  raw_ptr<password_manager::CredentialProviderInterface>
+      credential_provider_for_testing_ = nullptr;
+
+  // Java side of UI controller.
+  JavaObjectWeakGlobalRef weak_java_ui_controller_;
+
+  // Used to open the view/edit/delete UI.
+  std::unique_ptr<CredentialEditBridge> credential_edit_bridge_;
+};
+
+#endif  // CHROME_BROWSER_PASSWORD_MANAGER_ANDROID_PASSWORD_UI_VIEW_ANDROID_H_
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -679,7 +679,7 @@ For more settings that use data to improve your Chrome experience, go to <ph nam
         Passwords
       </message>
       <message name="IDS_PASSWORD_MANAGER_SETTINGS_TITLE" desc="Title for the settings menu item leading to the Password Manager UI surface. This allows users to e.g. manage their saved passwords, toggle saving and auto-sign-in on/off, etc. [CHAR_LIMIT=32]">
-        Google Password Manager
+        Password Manager
       </message>
       <message name="IDS_PASSWORD_SAVING_ON_BY_ADMINISTRATOR" desc="Subtitle for the settings menu item leading to the Password Manager UI surface, shown when the device administrator set saving passwords to enabled.">
         Password saving is turned on by your administrator
diff --git a/components/autofill/core/common/autofill_features.cc b/components/autofill/core/common/autofill_features.cc
--- a/components/autofill/core/common/autofill_features.cc
+++ b/components/autofill/core/common/autofill_features.cc
@@ -928,6 +928,7 @@ BASE_FEATURE(kAutofillAndroidDesktopSuppressAccessoryOnEmpty,
 BASE_FEATURE(kAutofillDeepLinkAutofillOptions,
              "AutofillDeepLinkAutofillOptions",
              base::FEATURE_ENABLED_BY_DEFAULT);
+SET_CROMITE_FEATURE_DISABLED(kAutofillDeepLinkAutofillOptions);
 
 // Controls if Chrome Autofill UI surfaces ignore touch events if something is
 // fully or partially obscuring the Chrome window.
diff --git a/components/password_manager/core/browser/buildflags.gni b/components/password_manager/core/browser/buildflags.gni
--- a/components/password_manager/core/browser/buildflags.gni
+++ b/components/password_manager/core/browser/buildflags.gni
@@ -9,7 +9,7 @@ declare_args() {
   # The legacy password store backend is supported on android but usually disabled
   # in favor of a downstream implementation. Important: the support for this flag
   # is planned to be removed in November 2024.
-  use_login_database_as_backend = !is_android
+  use_login_database_as_backend = true
 }
 
 # Drawables from the downstream clank/ repository are
diff --git a/components/password_manager/core/browser/features/password_manager_features_util.cc b/components/password_manager/core/browser/features/password_manager_features_util.cc
--- a/components/password_manager/core/browser/features/password_manager_features_util.cc
+++ b/components/password_manager/core/browser/features/password_manager_features_util.cc
@@ -28,6 +28,7 @@ namespace password_manager::features_util {
 namespace {
 
 bool IsUserEligibleForAccountStorage(const syncer::SyncService* sync_service) {
+  if ((true)) return false;
   if (!sync_service) {
     return false;
   }
diff --git a/components/sync/service/sync_prefs.cc b/components/sync/service/sync_prefs.cc
--- a/components/sync/service/sync_prefs.cc
+++ b/components/sync/service/sync_prefs.cc
@@ -713,7 +713,7 @@ bool SyncPrefs::IsTypeSupportedInTransportMode(UserSelectableType type) {
           kSeparateLocalAndAccountSearchEngines);
 #endif
     case UserSelectableType::kPasswords:
-      return true;
+      return false;
     case UserSelectableType::kAutofill:
       return true;
     case UserSelectableType::kPayments:
diff --git a/cromite_flags/components/password_manager/core/browser/features/password_features_cc/Restore-chrome-password-store.inc b/cromite_flags/components/password_manager/core/browser/features/password_features_cc/Restore-chrome-password-store.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/components/password_manager/core/browser/features/password_features_cc/Restore-chrome-password-store.inc
@@ -0,0 +1,5 @@
+SET_CROMITE_FEATURE_ENABLED(kSkipUndecryptablePasswords);
+
+#if BUILDFLAG(IS_ANDROID)
+SET_CROMITE_FEATURE_DISABLED(kLoginDbDeprecationAndroid);
+#endif  // BUILDFLAG(IS_ANDROID)
--
